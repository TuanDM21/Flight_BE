name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: main
  cancel-in-progress: true

jobs:
  build-and-push:
    name: Build and Push App Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image-tags: ${{ steps.meta.outputs.tags }}
      first-tag: ${{ fromJSON(steps.meta.outputs.json).tags[0] }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ·ï¸ Set custom tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "custom_tag=manual-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
          else
            echo "custom_tag=latest-$(date +%Y%m%d)" >> $GITHUB_OUTPUT
          fi

      - name: âš™ï¸ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ§© Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/tuandm21/backendquanlycanghangkhong
          tags: |
            type=raw,value=${{ steps.tag.outputs.custom_tag }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: ğŸ³ Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    needs: build-and-push
    if: github.ref == 'refs/heads/main'

    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ğŸ’¾ Pull and compress app image
        run: |
          IMAGE="${{ needs.build-and-push.outputs.first-tag }}"
          echo "ğŸ“¥ Pulling app image: $IMAGE"
          docker pull "$IMAGE"
          echo "ğŸ“¦ Compressing image..."
          docker save "$IMAGE" | gzip > app-image.tar.gz

      - name: ğŸ” Verify files before SCP
        run: |
          echo "ğŸ“‹ Verifying files exist:"
          ls -la app-image.tar.gz
          ls -la docker-compose.yml
          echo "ğŸ“ File sizes:"
          du -h app-image.tar.gz docker-compose.yml

      - name: ğŸ“¤ Copy to VPS
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          source: "app-image.tar.gz,docker-compose.yml"
          target: "${{ vars.DEPLOY_PATH }}"

      - name: ğŸš€ Deploy App Only
        uses: appleboy/ssh-action@v1.2.2
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT  }}
          script: |
            #!/bin/bash
            set -e

            echo "ğŸ”§ Starting deployment script..."
            echo "ğŸ“ Current directory: $(pwd)"
            echo "ğŸ‘¤ Current user: $(whoami)"

            # Navigate to deployment directory first
            DEPLOY_PATH="${{ vars.DEPLOY_PATH }}"
            echo "ğŸ“ Navigating to: $DEPLOY_PATH"
            cd "$DEPLOY_PATH"

            # Load new APP image
            echo "ğŸ”„ï¸ Loading new app image..."
            gunzip -c app-image.tar.gz | docker load
            NEW_APP_IMAGE="${{ needs.build-and-push.outputs.first-tag }}"

            # ï¿½ Verify .env file exists (created manually on VPS)
            echo "ï¿½ Checking for production .env file..."
            if [ ! -f .env ]; then
              echo "âŒ Error: .env file not found!"
              echo "ğŸ’¡ Please create .env file manually on VPS at: $DEPLOY_PATH/.env"
              echo "ğŸ“ Use the .env.example from the repository as a template"
              exit 1
            fi
            echo "âœ… Production .env file found"

            # ğŸ”„ Save current APP image for rollback
            OLD_APP_IMAGE=""
            if docker compose config --services | grep -q "app"; then
              OLD_APP_IMAGE=$(docker compose images app 2>/dev/null | tail -1 | awk '{print $2}' || true)
              if [ -n "$OLD_APP_IMAGE" ]; then
                echo "ğŸ” Saved rollback candidate (APP only): $OLD_APP_IMAGE"
              fi
            fi

            # ğŸ› ï¸ Update app and migration images in compose file
            echo "ğŸ“ Updating images in docker-compose.yml..."
            sed -i "s|^\(\s*\)image:\s*flight-mnm-backend:.*|\\1image: $NEW_APP_IMAGE|g" docker-compose.yml

            # ğŸ›‘ Stop app container
            echo "â¹ï¸ Stopping app container..."
            docker compose stop app 2>/dev/null || true

            # ğŸ”„ Run migration using migration service
            echo "â³ Running Flyway migrations..."
            echo "ğŸ” Checking migration service exists..."
            if docker compose config --services | grep -q "migration"; then
              echo "âœ… Migration service found"
              docker compose --profile migration run --rm migration \
                java -jar app.jar --spring.profiles.active=migration
              echo "âœ… Migration completed."
            else
              echo "âš ï¸ Migration service not found, skipping..."
            fi

            # ğŸš€ Start app container
            echo "ğŸš€ Starting app container..."
            echo "ğŸ” Available services:"
            docker compose config --services

            set +e
            docker compose up -d app
            EXIT_CODE=$?
            set -e

            echo "ğŸ“Š App container start exit code: $EXIT_CODE"

            if [ $EXIT_CODE -ne 0 ]; then
              echo "âŒ App failed to start."

                # ğŸ”„ Rollback APP
                if [ -n "$OLD_APP_IMAGE" ]; then
                  echo "ğŸ”„ Rolling back APP to: $OLD_APP_IMAGE"
                  sed -i "s|^\(\s*\)image:\s*[^[:space:]]*|\\1image: $OLD_APP_IMAGE|g" docker-compose.yml
                  docker compose up -d app
                  echo "âœ… App rollback completed."
                else
                  echo "âš ï¸ No rollback candidate for app."
                fi
                exit $EXIT_CODE
            fi

            # ğŸ” Verify deployment health
            echo "ğŸ” Verifying deployment health..."
            SERVER_PORT=${{ vars.SERVER_PORT || '8080' }}
            HEALTH_CHECK_RETRIES=12
            HEALTH_CHECK_INTERVAL=10
            STARTUP_GRACE_PERIOD=30

            echo "ğŸ” Checking app container status first..."
            docker compose ps app

            echo "ğŸ” Checking initial app logs..."
            docker compose logs --tail=20 app

            echo "â³ Waiting for application startup (${STARTUP_GRACE_PERIOD}s grace period)..."
            sleep $STARTUP_GRACE_PERIOD

            echo "ğŸ©º Starting health checks (${HEALTH_CHECK_RETRIES} attempts, ${HEALTH_CHECK_INTERVAL}s interval)..."
            for i in $(seq 1 $HEALTH_CHECK_RETRIES); do
              echo "â³ Health check attempt $i/$HEALTH_CHECK_RETRIES..."

              # Check if container is still running
              if ! docker compose ps app | grep -q "Up"; then
                echo "âŒ App container is not running!"
                echo "ğŸ” Container status:"
                docker compose ps app
                echo "ğŸ” Recent logs:"
                docker compose logs --tail=50 app
                exit 1
              fi

              # Try health check endpoint
              echo "ğŸ©º Checking health endpoint: http://localhost:${SERVER_PORT}/health"
              set +e
              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 http://localhost:${SERVER_PORT}/health)
              CURL_EXIT_CODE=$?
              set -e

              echo "ğŸ“Š HTTP Status: $HTTP_STATUS, Curl exit code: $CURL_EXIT_CODE"

              if [ $CURL_EXIT_CODE -eq 0 ] && [ "$HTTP_STATUS" = "200" ]; then
                echo "âœ… Application is healthy! (HTTP 200)"
                # Get the actual response for logging
                HEALTH_RESPONSE=$(curl -s --max-time 5 http://localhost:${SERVER_PORT}/health 2>/dev/null || echo "Could not fetch response")
                echo "ğŸ©º Health check response: $HEALTH_RESPONSE"
                break
              else
                echo "âš ï¸ Health check failed - HTTP: $HTTP_STATUS, Curl: $CURL_EXIT_CODE"
                if [ $CURL_EXIT_CODE -ne 0 ]; then
                  echo "ï¿½ Connection error - application may still be starting up"
                fi
              fi

              if [ $i -eq $HEALTH_CHECK_RETRIES ]; then
                TOTAL_WAIT_TIME=$((STARTUP_GRACE_PERIOD + HEALTH_CHECK_RETRIES * HEALTH_CHECK_INTERVAL))
                echo "âŒ Health check failed after $HEALTH_CHECK_RETRIES attempts (${TOTAL_WAIT_TIME}s total)"
                echo "ğŸ” Final container status:"
                docker compose ps app
                echo "ğŸ” Final app logs:"
                docker compose logs --tail=100 app
                echo "ğŸ” System resources:"
                df -h
                free -m

                echo "ğŸ©º Manual health check attempts:"
                echo "ğŸ”— Testing health endpoint..."
                curl -v http://localhost:${SERVER_PORT}/health || true
                echo ""
                echo "ğŸ”— Testing root endpoint..."
                curl -v http://localhost:${SERVER_PORT}/ || true
                echo ""
                echo "ğŸ”— Port connectivity test..."
                nc -zv localhost ${SERVER_PORT} || true

                # Trigger rollback on health check failure
                if [ -n "$OLD_APP_IMAGE" ]; then
                  echo "ğŸ”„ Rolling back due to health check failure..."
                  sed -i "s|^\(\s*\)image:\s*[^[:space:]]*|\\1image: $OLD_APP_IMAGE|g" docker-compose.yml
                  docker compose up -d app
                  echo "âœ… Rollback completed due to health check failure."
                fi
                exit 1
              fi

              echo "â³ Waiting for application to be ready... ($i/$HEALTH_CHECK_RETRIES)"
              sleep $HEALTH_CHECK_INTERVAL
            done

            # ğŸ“Š Display final status
            echo "ğŸ“Š Deployment Status:"
            docker compose ps app
            echo "ğŸŒ Application URL: http://localhost:${SERVER_PORT}"
            echo "ğŸ“‹ Health Check: http://localhost:${SERVER_PORT}/health"

            # ğŸ§¹ Cleanup old Docker images and containers
            echo "ğŸ§¹ Cleaning up Docker resources..."
            # Remove old images (keep last 3 versions)
            docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
              grep "ghcr.io/tuandm21/backendquanlycanghangkhong" | \
              tail -n +4 | \
              awk '{print $1}' | \
              xargs -r docker rmi || true

            # Remove unused containers and networks
            docker container prune -f
            docker network prune -f

            # Remove build cache older than 7 days
            docker builder prune --filter until=168h -f

            rm -f app-image.tar.gz

            echo "âœ… Deployment completed successfully."
            echo "ğŸ‰ CI/CD Pipeline finished with SUCCESS status"

            # Explicit success exit
            exit 0
